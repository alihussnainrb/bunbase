import type { SQL } from 'bun'
import { getSQLPool } from './pool.ts'
import { setRLSContext } from './session-vars.ts'

/**
 * Typed DB client - generic over your Database schema
 */

interface TableDef {
	Row: Record<string, any>
	Insert: Record<string, any>
	Update: Record<string, any>
}

export type BaseDatabase = {
	public: {
		Tables: Record<string, TableDef>
	}
}

/**
 * Augmented via `.bunbase/database.d.ts` generated by `bunbase typegen`.
 */
export type GeneratedDatabase = {}

type GeneratedTables = GeneratedDatabase extends {
	public: { Tables: infer Tables extends Record<string, TableDef> }
}
	? Tables
	: never

type ResolvedTables = [GeneratedTables] extends [never]
	? BaseDatabase['public']['Tables']
	: GeneratedTables

export type Database = {
	public: {
		Tables: ResolvedTables
	}
}

type InferTables<DB extends Database> = DB['public']['Tables']

type InferTable<
	DB extends Database,
	T extends keyof InferTables<DB>,
> = InferTables<DB>[T]

export type DatabaseClient<DB extends Database = Database> = {
	from: <T extends keyof InferTables<DB>>(
		table: T,
	) => TypedQueryBuilder<InferTable<DB, T>>

	raw: (strings: TemplateStringsArray, ...values: any[]) => Promise<any[]>

	/**
	 * Execute a function within a database transaction.
	 * Automatically commits on success, rolls back on error.
	 *
	 * @example
	 * await ctx.db.transaction(async (tx) => {
	 *   await tx.from('accounts').eq('id', fromId).update({ balance: fromBalance - amount })
	 *   await tx.from('accounts').eq('id', toId).update({ balance: toBalance + amount })
	 * })
	 */
	transaction: <T>(fn: (tx: DatabaseClient<DB>) => Promise<T>) => Promise<T>
}

export function createDB<DB extends Database = Database>(
	sql?: SQL,
): DatabaseClient<DB> {
	const pool = sql ?? getSQLPool()

	function buildClient(conn: SQL): DatabaseClient<DB> {
		return {
			from: <T extends keyof InferTables<DB>>(table: T) => {
				return new TypedQueryBuilder<InferTable<DB, T>>(table as string, conn)
			},

			raw: (strings: TemplateStringsArray, ...values: any[]) => {
				return conn(strings, ...values)
			},

			transaction: <T>(
				fn: (tx: DatabaseClient<DB>) => Promise<T>,
			): Promise<T> => {
				return conn.begin(async (txConn: SQL) => {
					const txClient = buildClient(txConn)
					return fn(txClient)
				})
			},
		}
	}

	return buildClient(pool)
}

class TypedQueryBuilder<Table extends TableDef> {
	private table: string
	private sql: SQL
	private selects: (keyof Table['Row'])[] | ['*'] = ['*']
	private wheres: Array<{ col: keyof Table['Row']; op: string; val: any }> = []
	private joins: Array<{
		type: 'INNER' | 'LEFT'
		table: string
		thisCol: string
		otherCol: string
	}> = []
	private limitNum: number | null = null
	private offsetNum: number | null = null
	private orderByCol: keyof Table['Row'] | null = null
	private orderByDir: 'ASC' | 'DESC' = 'ASC'
	private returningFields: (keyof Table['Row'])[] | null = null

	constructor(table: string, sql: SQL) {
		this.table = table
		this.sql = sql
	}

	select<
		Fields extends keyof Table['Row'] | '*',
		Result = Fields extends '*'
			? Table['Row']
			: Pick<Table['Row'], Fields extends keyof Table['Row'] ? Fields : never>,
	>(
		...fields: Fields[]
	): TypedQueryBuilder<Table> & { exec: () => Promise<Result[]> } {
		this.selects = (fields.length ? fields : ['*']) as any
		return this as any
	}

	eq<K extends keyof Table['Row']>(column: K, value: Table['Row'][K]): this {
		this.wheres.push({ col: column, op: '=', val: value })
		return this
	}

	neq<K extends keyof Table['Row']>(column: K, value: Table['Row'][K]): this {
		this.wheres.push({ col: column, op: '!=', val: value })
		return this
	}

	gt<K extends keyof Table['Row']>(column: K, value: Table['Row'][K]): this {
		this.wheres.push({ col: column, op: '>', val: value })
		return this
	}

	gte<K extends keyof Table['Row']>(column: K, value: Table['Row'][K]): this {
		this.wheres.push({ col: column, op: '>=', val: value })
		return this
	}

	lt<K extends keyof Table['Row']>(column: K, value: Table['Row'][K]): this {
		this.wheres.push({ col: column, op: '<', val: value })
		return this
	}

	lte<K extends keyof Table['Row']>(column: K, value: Table['Row'][K]): this {
		this.wheres.push({ col: column, op: '<=', val: value })
		return this
	}

	like<K extends keyof Table['Row']>(column: K, pattern: string): this {
		this.wheres.push({ col: column, op: 'LIKE', val: pattern })
		return this
	}

	ilike<K extends keyof Table['Row']>(column: K, pattern: string): this {
		this.wheres.push({ col: column, op: 'ILIKE', val: pattern })
		return this
	}

	isNull<K extends keyof Table['Row']>(column: K): this {
		this.wheres.push({ col: column, op: 'IS NULL', val: null })
		return this
	}

	isNotNull<K extends keyof Table['Row']>(column: K): this {
		this.wheres.push({ col: column, op: 'IS NOT NULL', val: null })
		return this
	}

	in<K extends keyof Table['Row']>(column: K, values: Table['Row'][K][]): this {
		this.wheres.push({ col: column, op: 'IN', val: values })
		return this
	}

	limit(n: number): this {
		this.limitNum = n
		return this
	}

	offset(n: number): this {
		this.offsetNum = n
		return this
	}

	orderBy<K extends keyof Table['Row']>(
		column: K,
		direction: 'ASC' | 'DESC' = 'ASC',
	): this {
		this.orderByCol = column
		this.orderByDir = direction
		return this
	}

	returning<Fields extends keyof Table['Row']>(fields: Fields[]): this {
		this.returningFields = fields
		return this
	}

	/**
	 * Add an INNER JOIN clause.
	 *
	 * @example
	 * db.from('orders')
	 *   .innerJoin('users', 'user_id', 'id')
	 *   .select('*')
	 *   .exec()
	 */
	innerJoin(table: string, thisCol: string, otherCol: string): this {
		this.joins.push({ type: 'INNER', table, thisCol, otherCol })
		return this
	}

	/**
	 * Add a LEFT JOIN clause.
	 *
	 * @example
	 * db.from('users')
	 *   .leftJoin('profiles', 'id', 'user_id')
	 *   .select('*')
	 *   .exec()
	 */
	leftJoin(table: string, thisCol: string, otherCol: string): this {
		this.joins.push({ type: 'LEFT', table, thisCol, otherCol })
		return this
	}

	async single(ctx?: { session?: any }): Promise<Table['Row'] | null> {
		const rows = await this.limit(1).exec(ctx)
		return rows[0] ?? null
	}

	async maybeSingle(ctx?: { session?: any }): Promise<Table['Row'] | null> {
		const rows = await this.limit(1).exec(ctx)
		if (rows.length > 1) return null
		return rows[0] ?? null
	}

	async count(ctx?: { session?: any }): Promise<number> {
		if (ctx) await setRLSContext(this.sql, ctx)

		let query = this.sql`SELECT COUNT(*) as count FROM ${this.sql(this.table)}`

		if (this.joins.length > 0) {
			query = this.buildJoinClauses(query)
		}

		if (this.wheres.length > 0) {
			const whereClause = this.buildWhereClause()
			query = this.sql`${query} WHERE ${whereClause}`
		}

		const result = await query
		return Number(result[0]?.count ?? 0)
	}

	private buildJoinClauses(query: any): any {
		let q = query
		for (const j of this.joins) {
			const joinType = this.sql.unsafe(`${j.type} JOIN`)
			q = this
				.sql`${q} ${joinType} ${this.sql(j.table)} ON ${this.sql(this.table)}.${this.sql(j.thisCol)} = ${this.sql(j.table)}.${this.sql(j.otherCol)}`
		}
		return q
	}

	private buildWhereClause() {
		const conditions = this.wheres.map((w) => {
			if (w.op === 'IN') {
				return this.sql`${this.sql(w.col)} IN (${this.sql(w.val)})`
			}
			if (w.op === 'IS NULL') {
				return this.sql`${this.sql(w.col)} IS NULL`
			}
			if (w.op === 'IS NOT NULL') {
				return this.sql`${this.sql(w.col)} IS NOT NULL`
			}
			const op = this.sql.unsafe(w.op)
			return this.sql`${this.sql(w.col)} ${op} ${w.val}`
		})

		return conditions.reduce((acc, curr, i) => {
			if (i === 0) return curr
			return this.sql`${acc} AND ${curr}`
		}, this.sql``)
	}

	async exec(ctx?: { session?: any }): Promise<Table['Row'][]> {
		if (ctx) await setRLSContext(this.sql, ctx)

		let query = this
			.sql`SELECT ${this.sql(this.selects)} FROM ${this.sql(this.table)}`

		if (this.joins.length > 0) {
			query = this.buildJoinClauses(query)
		}

		if (this.wheres.length > 0) {
			const whereClause = this.buildWhereClause()
			query = this.sql`${query} WHERE ${whereClause}`
		}

		if (this.orderByCol !== null) {
			const dir = this.sql.unsafe(this.orderByDir)
			query = this.sql`${query} ORDER BY ${this.sql(this.orderByCol)} ${dir}`
		}

		if (this.limitNum !== null) {
			query = this.sql`${query} LIMIT ${this.limitNum}`
		}

		if (this.offsetNum !== null) {
			query = this.sql`${query} OFFSET ${this.offsetNum}`
		}

		const result = await query
		return result as Table['Row'][]
	}

	async insert(
		data: Table['Insert'],
		ctx?: { session?: any },
	): Promise<Table['Row'] | null> {
		if (ctx) await setRLSContext(this.sql, ctx)

		let q = this.sql`INSERT INTO ${this.sql(this.table)} ${this.sql(data)}`

		if (this.returningFields) {
			q = this.sql`${q} RETURNING ${this.sql(this.returningFields)}`
		} else {
			q = this.sql`${q} RETURNING *`
		}

		const result = await q
		return (result[0] as Table['Row']) ?? null
	}

	async update(
		data: Table['Update'],
		ctx?: { session?: any },
	): Promise<Table['Row'][]> {
		if (ctx) await setRLSContext(this.sql, ctx)

		let q = this.sql`UPDATE ${this.sql(this.table)} SET ${this.sql(data)}`

		if (this.wheres.length > 0) {
			const whereClause = this.buildWhereClause()
			q = this.sql`${q} WHERE ${whereClause}`
		}

		if (this.returningFields) {
			q = this.sql`${q} RETURNING ${this.sql(this.returningFields)}`
		} else {
			q = this.sql`${q} RETURNING *`
		}

		const result = await q
		return result as Table['Row'][]
	}

	async delete(ctx?: { session?: any }): Promise<Table['Row'][]> {
		if (ctx) await setRLSContext(this.sql, ctx)

		let q = this.sql`DELETE FROM ${this.sql(this.table)}`

		if (this.wheres.length > 0) {
			const whereClause = this.buildWhereClause()
			q = this.sql`${q} WHERE ${whereClause}`
		}

		if (this.returningFields) {
			q = this.sql`${q} RETURNING ${this.sql(this.returningFields)}`
		} else {
			q = this.sql`${q} RETURNING *`
		}

		const result = await q
		return result as Table['Row'][]
	}
}
